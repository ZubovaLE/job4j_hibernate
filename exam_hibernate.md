# Экзамен.Hibernate

## Оглавление

1. [Что такое ORM?](#1-Что-такое-ORM)
2. [Опиши, как конфигурируется Hibernate. Рассказать про hibernate.cfg.xml и про mapping.](#2-Опиши-как-конфигурируется-Hibernate-Рассказать-про-hibernatecfgxml-и-про-mapping)
3. [Жизненный цикл Entity.](#3-Жизненный-цикл-Entity)
4. [Зачем нужен класс SessionFactory? Является ли он потокобезопасным?](#4-Зачем-нужен-класс-SessionFactory-Является-ли-он-потокобезопасным)
5. [Зачем нужен класс Session? Является ли он потокобезопасным?](#5-Зачем-нужен-класс-Session-Является-ли-он-потокобезопасным)
6. [В чем отличие методов Session.get Session.load?](#6-В-чем-отличие-методов-Sessionget-Sessionload)
7. [Расскажите про методы flush и close.](#7-Расскажите-про-методы-flush-и-close)
8. [В чем отличие методы save от saveOrUpdate и merge?](#8-В-чем-отличие-методы-save-от-saveOrUpdate-и-merge)
9. [Расскажите про процесс создания, редактирования, чтения и удаления данных через Hibernate.](#9-Расскажите-про-процесс-создания-редактирования-чтения-и-удаления-данных-через-Hibernate)
10. [Как осуществляется иерархия наследования в Hibernate? Рассказать про три стратегии наследования.](#10-Как-осуществляется-иерархия-наследования-в-Hibernate-Рассказать-про-три-стратегии-наследования)
11. [Можно ли создать собственный тип данных?](#11-Можно-ли-создать-собственный-тип-данных)
12. [Какие коллекции поддерживаются на уровне mapping?](#12-Какие-коллекции-поддерживаются-на-уровне-mapping)
13. [Зачем нужен класс Transactional?](#13-Зачем-нужен-класс-Transactional)
14. [Расскажите про уровни изоляции? Какие уровни поддерживаются в hibernate? Как их устанавливать?](#14-Расскажите-про-уровни-изоляции-Какие-уровни-поддерживаются-в-hibernate-Как-их-устанавливать)
15. [Что такое OptimisticLock? Расскажите стратегии создания через version, timestamp.](#15-Что-такое-OptimisticLock-Расскажите-стратегии-создания-через-version-timestamp)
16. [Расскажите про стратегии извлечения данных eager, lazy?](#16-Расскажите-про-стратегии-извлечения-данных-eager-lazy)
17. [Что такое объект Proxy? С чем связана ошибка LazyInitializationException? Как ее избежать?](#17-Что-такое-объект-Proxy-С-чем-связана-ошибка-LazyInitializationException-Как-ее-избежать)
18. [HQL. Расскажи основные элементы синтаксиса HQL? Простой запрос, запрос join? Создания объекта через конструктор.](#18-HQL-Расскажи-основные-элементы-синтаксиса-HQL-Простой-запрос-запрос-join-Создания-объекта-через-конструктор)
19. [Расскажите про уровни кешей в Hibernate?](#19-Расскажите-про-уровни-кешей-в-Hibernate)
20. [Что такое StatelessSessionFactory? Зачем он нужен, где он используется?](#20-Что-такое-StatelessSessionFactory-Зачем-он-нужен-где-он-используется)
21. [Зачем нужен режим read-only?](#21-Зачем-нужен-режим-read-only)

## 1 Что такое ORM?

ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология
программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования.

ORM по сути является маппингом Java-объектов на SQL-запросы.

[К оглавлению &#8593;](#Оглавление)

## 2 Опиши, как конфигурируется Hibernate. Рассказать про hibernate.cfg.xml и про mapping.

Конфигурация осуществляется с помощью файла настроек hibernate.cfg.xml, который размещается в папке resources. Пример
файла:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
        <property name="hibernate.connection.url">jdbc:postgresql://127.0.0.1:5432/example</property>
        <property name="hibernate.connection.username">postgres</property>
        <property name="hibernate.connection.password">password</property>
        <property name="hibernate.connection.pool_size">1</property>
        <property name="hibernate.current_session_context_class">thread</property>
        <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQL10Dialect</property>
        <property name="hibernate.hbm2ddl.auto">update</property>
        <property name="show_sql">true</property>
        <property name="format_sql">true</property>
        <property name="use_sql_comments">true</property>

        <mapping class="ru.job4j.example.Example"/>
    </session-factory>
</hibernate-configuration>
```

В тегах <property> прописываются необходимые настройки.  
К примеру, благодаря включению свойства `<property name="show_sql">` мы можем в консоли увидеть те запросы к базе
данных, которые выполняет Hibernate.

Свойство `<property name="hibernate.hbm2ddl.auto">update</property>` отвечает за генерацию структуры таблиц в БД,
значение update говорит о том, что в случае различия фактического состояния структуры таблицы и той, которая необходима
для работы, Hibernate самостоятельно изменит структуру таблицы. Кроме того, Hibernate создаст таблицу, если при запуске
кода таблицы вообще не будет в БД.

Кроме того, Hibernate требует перечисления всех проаннотированных классов в конфигурации, поэтому мы
используем `<mapping class="ru.job4j.example.Example"/>`

[К оглавлению &#8593;](#Оглавление)

## 3 Жизненный цикл Entity.

Если имеется какой-то Entity-объект, который можно сохранять в базу с помощью Hibernate, то с точки зрения Hibernate у
этого объекта может быть четыре состояния:

- Transient
- Persistent (or Managed)
- Detached
- Removed

**Transient**  
Каждый Entity объект, который был создан явно с помощью Java-кода, а не загружен из базы с помощью Hibernate, имеет
статус Transient (промежуточный). Статус Transient значит, что Hibernate понятия не имеет об этом объекте и никакие
действия с объектом не влияют на Hibernate, как и работа Hibernate на этот объект.

```
Example example = new Example (); 
```

Такие объекты еще называются POJO – Plain Old Java Object.

**Persistent or Managed**  
Состояние Persistent (или же Managed) можно получить двумя способами:

1. Загрузить объект из Hibernate
2. Сохранить объект в Hibernate

```
Example example = session.load(Example.class, 1); 
```

```
Example example = new Example (); 
session.save(example);
```

Такому объекту обычно соответствует какая-то запись в базе данных. Этот объект присоединен к сессии Hibernate’а, и может
быть представлен не реальным объектом, а неким proxy.

**Detached**  
Состояние Detached – это когда объект был отсоединен от сессии, то есть сначала объект был присоединен к сессии
Hibernate, но затем сессия закрылась или транзакция завершилась, поэтому Hibernate больше не следит за этим объектом.

Пример:

```
session.close(); 
```

```
session.evict(entity); // явно указали, что хотим отсоединить объект от сессии с помощью метода evict(). Данный метод 
удаляет объект из кэша cессии
```

И вот тут будет самое интересное. Если твой объект был получен из Hibernate, то велика вероятность, что тебе отдали
некий proxy вместо реального объекта. И этот proxy-объект после отсоединения от сессии будет кидать исключения при
вызове его методов.

Это самая частая проблема у всех новичков при работе с Hibernate. Тебе нужно точно знать в каждый момент времени ответ
на такие вопросы, когда ты работаешь с Entity-объектом:

**Removed**
Состояние Removed – это состояние удаленного объекта. Такое состояние появляется по причине того, что при удалении
объекта из базы, Java-объект сразу никуда не исчезнет.

```

Employee employee = session.load(Employee.class, 1); //после загрузки у объекта состояние Persisted

session.remove(employee); //после удаления у объекта состояние Removed

session.save(employee); //а теперь снова Persisted

session.close(); //а теперь состояние Detached
```

[К оглавлению &#8593;](#Оглавление)

## 4 Зачем нужен класс SessionFactory? Является ли он потокобезопасным?

SessionFactory - это объект конфигуратор. Он создается один раз на все приложение. В нем происходит создания пулов,
загрузка кешей, проверка моделей.

Создание этого объекта трудозатратное.

Т.к. объект SessionFactory immutable (неизменяемый), то он **потокобезопасный**. Множество потоков может обращаться к
одному объекту одновременно.

[К оглавлению &#8593;](#Оглавление)

## 5 Зачем нужен класс Session? Является ли он потокобезопасным?

Объект Session позволяет записать, удалить и прочитать данные из базы.

Объект Hibernate Session **не является потокобезопасным**. Каждый поток должен иметь свой собственный объект Session и
закрывать его по окончанию.

[К оглавлению &#8593;](#Оглавление)

## 6 В чем отличие методов Session.get Session.load?

get() загружает данные сразу при вызове, в то время как load() использует прокси объект и загружает данные только тогда,
когда это требуется на самом деле. В этом плане load() имеет преимущество в плане ленивой загрузки данных. load()
бросает исключение, когда данные не найдены. Поэтому его нужно использовать только при уверенности в существовании
данных. Нужно использовать метод get(), если необходимо удостовериться в наличии данных в БД.

[К оглавлению &#8593;](#Оглавление)

## 7 Расскажите про методы flush и close.

flush и close - методы сессии:

- flush() — синхронизирует объекты сессии с БД и в то же время обновляет сам кэш сессии
- clear() — очищает весь кеш

[К оглавлению &#8593;](#Оглавление)

## 8 В чем отличие методы save от saveOrUpdate и merge?

- save() используется для сохранения сущности в базу данных. Проблема с использованием метода save() заключается в том,
  что он может быть вызван без транзакции. А следовательно если у нас имеется отображение нескольких объектов, то только
  первичный объект будет сохранен и мы получим несогласованные данные. Также save() немедленно возвращает
  сгенерированный идентификатор.

- saveOrUpdate() использует запрос для вставки или обновления, основываясь на предоставленных данных. Если данные уже
  присутствуют в базе данных, то будет выполнен запрос обновления. Метод saveOrUpdate() можно применять без транзакции,
  но это может привести к аналогичным проблемам, как и в случае с методом save().

- merge() может быть использован для обновления существующих значений, однако этот метод создает копию из переданного
  объекта сущности и возвращает его. Возвращаемый объект является частью контекста персистентности и отслеживает любые
  изменения, а переданный объект не отслеживается.

[К оглавлению &#8593;](#Оглавление)

## 9 Расскажите про процесс создания, редактирования, чтения и удаления данных через Hibernate.

- сохранение transient объекта в базе данных, т.е. перевода его в состояние persistent.  
  Сущность сохраняют в базу данных с помощью метода _**save()**_. Особенность этого метода в том, что он сразу
  возвращает первичный ключ сущности и при этом генерирует sql команду insert, если его первичным ключом является поле,
  для которого используется метод генерации “identity”, а не “sequence”. Используется в рамках одной транзакции:

```
session.getTransaction().begin();
Person person = new Person();
Long id = (Long) session.save(person);
session.getTransaction().begin();
```

Также есть метод _**persist()**_, который тоже переводит объект из состояния transient в состояние persistent, однако
persist() не пытается сразу же вернуть первичный ключ сущности. Его применяют, если операции у нас продолжительны по
времени. Вызов sql команды insert может быть отложен на момент коммита транзакции commit() или вызова метода flush().
Используется обычно для длительных по времени и сложных последовательностей операций вне рамок транзакций:

```
session = sessionFactory.openSession();
session.getTransaction().begin();
Person person = new Person();
session.getTransaction().commit();
…
session.persist(person);
//вызов вне рамок транзакции!
…
session.getTransaction().begin();
session.flush();
session.close();
```

Итак, если объект сущности связан с сессией, то он находится в состоянии persistent, при выходе за рамки сессии сущность
переходит в состояние detached.

- Для того чтобы изменения, сделанные вне сессии/транзакции, применились для detached объекта, нужно обратно перевести
  его в состояние persistent, это делается методом update():

```
Long id = (Long) session.save(person); 
session.getTransaction().commit(); 
session.close();
 
person.setFirstName("Oleg"); 

session = sessionFactory.openSession(); 
session.getTransaction().begin(); 
session.update(person); 
session.getTransaction().commit(); 
session.close();
```

В этом примере для метода update() есть свой подводный камень. Допустим, в сессии есть объект с первичным ключом
сущности, который уже связан с сессией, и такой же ключ имеет наш detached объект, и если мы попытаемся выполнить по
нему метод update(), то мы получим исключительную ситуацию org.hibernate.NonUniqueObjectException:

```
Long id = (Long) session.save(person);
session.getTransaction().commit();
session.close();

person.setFirstName("Oleg");

session = sessionFactory.openSession();
session.getTransaction().begin();
Person person2 = (Person)session.get(Person.class,id);
session.update(person); // получим ошибку org.hibernate.NonUniqueObjectException 
session.getTransaction().commit();
session.close();
```

Чтобы избежать исключительной ситуации, необходимо применить **_merge()_**. Эта команда возвращает ссылку на копию новой
сущности, при этом берется persistent объект с таким же ключом, как у detached объекта, все изменения перезаписываются с
detached объекта поверх persistent объекта. После этого мы имеем два объекта: detached объект и копию ссылки на
persistent объект с копированными значениями полей detached сущности. Далее мы работаем с копией, как с persistent
объектом, и все изменения, которые мы хотим сохранить в базе данных, мы применяем к этой копии. Т.е. метод merge() не
переводит сущность из detached состояния в состояние persistent, как метод update():

```
Person person = new Person();
person.setFirstName("Name");
person.setSecondName("Lastname");
Long id = (Long) session.save(person);             
session.getTransaction().commit();
session.close();

person.setFirstName("Oleg");
session = sessionFactory.openSession();
session.getTransaction().begin();
Person person2 = (Person)session.get(Person.class,id);
System.out.printf("Person select person2: %s\n", person2);
Person person3 = (Person)session.merge(person);
person.setFirstName("Vika"); \\ эти изменения никогда не попадут в базу данных

\\ дальше нужно работать с копией person3, как с persistent объектом
System.out.printf("Person select  person2: %s\n", person2);
if (person != person3) {
System.out.format("ссылка на новый instance\n");
}
session.flush();
person = (Person)session.get(Person.class,id);
System.out.printf("Person select: %s\n", person);
    
\\ Вывод: Person select: Person{id=1, firstName='Oleg', secondName='Lastname'}
```

- метод **_saveOrUpdate()_** вобрал в себя поведение методов save() и update(). Если нет объекта, то метод
  saveOrUpdate() ведет себя как save() и создает persistent объект в сессии, иначе он ведет себя как метод update(), то
  есть обновляет объект.
- Для удаления сущности нужно выполнить метод сессии **_delete()_**, сущность будет переведена в состояние removed, а
  после выполнения методов flush() или commit() будет удалена и из таблицы базы данных.
- Прочитать сущность можно несколькими способами: методы **_get()_** и **_load()_** возвращают нам сущности по заранее
  известному нам ключу. Для чтения множества “массива” сущностей можно прибегнуть к двум методам: вернуть сразу все
  записи методом **_list()_** или работать с итератором (Iterator). Итератор нужно и можно использовать для повышения
  производительности запроса данных, если запрос находится в кэше второго уровня и выборка данных идет из кэша. Если нет
  данных в кэше, то запрос с итератором будет работать дольше, чем запрос методом .list().

```
List<Person> persons = session.createCriteria(Person.class).list();
        for(Person p:persons) {
        System.out.printf("%s\n",p);
        } 
```

```
Iterator<Person> iterator = session.createQuery("from Person").iterate();
while (iterator.hasNext()) {
    Person p = iterator.next();
    System.out.printf("%s\n", p);
}
```

- Постраничная выборка или pagination: мы можем ограничить результаты выборки и обрабатывать всё малыми порциями. В этом
  нам помогут команды **_setMaxResults()_** (количество сущностей, которое нужно вернуть в запросе) и
  **_setFirstResult()_** (с какой сущности нужно начать). Например, вывести 5 сущностей, пропустив десять первых
  сущностей в выборке:

```
persons = session.createCriteria(Person.class).setMaxResults(5).setFirstResult(10).list();
```

[К оглавлению &#8593;](#Оглавление)

## 10 Как осуществляется иерархия наследования в Hibernate? Рассказать про три стратегии наследования.

Иерархия классов — это несколько классов, связанных друг с другом отношением наследования. Главное противоречие между
объектно-ориентированной и реляционной моделями заключается в том, объектная модель поддерживает два вида отношений («is
a» — “является”, и «has a» — “имеет”), а модели, основанные на SQL, поддерживают только отношения «has a».

Иными словами, SQL не понимает наследование типов и не поддерживает его. Поэтому на этапе построения сущностей и схемы
БД одной из главных задач разработчика будет выбор оптимальной стратегии представления иерархии наследования.

В Hibernate существует 4 возможных способа, которыми он может связать иерархию классов с таблицами в базе данных:

- MappedSuperclass
- Single Table
- Joined Table
- Table per class

_**@MappedSuperClass**_
В базе данных для каждого класса отдельные таблицы. О том, что классы для этих таблиц связаны в иерархию, знает только
разработчик. Если требуется, чтобы еще и Hibernate об этом знал, нужно добавить родительскому классу аннотацию
@MappedSuperclass. Без нее Hibernate просто проигнорирует поля и аннотации родительского класса.

**_Single Table_**
Следующий подход к хранению иерархии классов – это хранить все классы иерархии в одной таблице. Такая стратегия
называется Single Table. Например, так:

```
CREATE TABLE user_ employee_client (
id INT,
name VARCHAR,
birthday DATE,
occupation VARCHAR,
salary INT,
join DATE,
address VARCHAR,
DTYPE VARCHAR
)
```

То есть одна таблица, у которой колонки для всех классов иерархии обозначены разными цветами. Также есть специальная
служебная колонка DTYPE VARCHAR, где Hibernate будет хранить имя Entity-класса.

Дале нужно объяснить Hibernate, что данные Entity-классов теперь хранятся в базе в одной таблице. Сделать это можно с
помощью аннотации _@Inheritance(strategy = InheritanceType.SINGLE_TABLE)_. Пример:

```java

@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@Entity
class User {
    int id;
    String name;
    LocalDate birthday;
}

@Entity
class Employee extends User {
    String occupation;
    int salary;
    LocalDate join;
}

@Entity
class Client extends User {
    String address;
}
```

Теперь напишем пример, где создадим несколько сущностей и сохраним их в базу:

```
Employee employee = new Employee();
employee.id = 101;
employee.name = "Иванов";
employee.birthday = LocalDate.of("01-01-1999");
employee.occupation = "Программист"
employee.salary = 100000;
employee.join = LocalDate.of("12-01-2018");
session.persist(employee);

Client client = new Client();
client.id = 102;
client.name = "Петров";
client.birthday = LocalDate.of("15-11-1988");
client.address = "Шандара";
session.persist(client);
```

При сохранении в базу данных будет выполнен такой SQL-запрос:

```
INSERT INTO user_ employee_client (id, name, birthday, occupation, salary, join, DTYPE)
VALUES (101, 'Иванов', '01-01-1999', 'Программист', 100000, '12-01-2018', 'Employee')

INSERT INTO user_ employee_client (id, name, birthday, address, DTYPE)
VALUES (102, 'Петров', '15-11-1988', 'Шандара', 'Client')
```

При сохранении данных в таблицу Hibernate передает только известные ему поля сущностей. Это означает, что неуказанные
колонки будут иметь значение NULL. Это значит, что нельзя указать для колонки occupation тип NOT NULL, так как при
хранении клиента в этой же таблице его occupation будет NULL. Это один из минусов хранения разных сущностей в одной
таблице.

Последнее поле в SQL-запросе – это колонка DTYPE, в ней передается имя Entity-класса. Такая колонка называется
**_дискриминатор_**. Ее используют для того, чтобы однозначно определить, какой класс нужно создать для данной строки
базы данных. Прочитаем данные из таблицы:

```
List<User> accounts = session.createQuery("from User").list(); 
```

Данный запрос вернет список всех сохраненных в базе объектов типа пользователь: User, Employee и Client. На основе
колонки DTYPE будет правильно определен тип сущности и создан объект правильного класса.

**Joined Table**
Еще одна стратегия хранения иерархии классов в базе данных называется Joined Table. Для нее есть специальная аннотация:
@Inheritance(strategy = InheritanceType.JOINED)

Пример наших классов:

```java

@Inheritance(strategy = InheritanceType.JOINED)
@Entity
class User {
    int id;
    String name;
    LocalDate birthday;
}

@Entity
class Employee extends User {
    String occupation;
    int salary;
    LocalDate join;
}

@Entity
class Client extends User {
    String address;
}
```

При использовании этой аннотации Hibernate будет ожидать в базе отдельную таблицу для каждого класса и его подклассов.
При выборке данных из них придется использовать SQL-оператор JOIN.

Пример схемы базы данных:

```
CREATE TABLE user ( 
  id INT, 
  name VARCHAR, 
  birthday DATE 
)
 
CREATE TABLE employee ( 
  id INT, 
  occupation VARCHAR, 
  salary INT, 
  join DATE 
)

CREATE TABLE client ( 
  id INT, 
  address VARCHAR 
)
``` 

Если нужно получить из таблицы данные какого-нибудь клиента, то Hibernate придется использовать JOIN для объединения
таблиц:

```
SELECT u.id, u.name, u.birthday, c.address FROM user u JOIN client c ON u.id = c.id; 
```

**Table per class**
Стратегия Table per class означает, что для каждого класса будет использоваться отдельная таблица. В каком-то смысле это
тот же MappedSuperClass, только в обновленном виде.

Во-первых, нужно использовать аннотацию: @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS):

```java

@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
@Entity
class User {
    int id;
    String name;
    LocalDate birthday;
}

@Entity
class Employee extends User {
    String occupation;
    int salary;
    LocalDate join;
}

@Entity
class Client extends User {
    String address;
}
```

И отдельные таблицы для каждого класса. Например, такие:

```
CREATE TABLE user {
id INT,
name VARCHAR,
birthday DATE
}

CREATE TABLE employee {
id INT,
name VARCHAR,
birthday DATE,
occupation VARCHAR,
salary INT,
join DATE
}

CREATE TABLE client {
id INT,
name VARCHAR,
birthday DATE,
address VARCHAR
}
```

Основное отличие – это то, что используется сквозной id (PRIMARY KEY) для всех таблиц. Не могут быть разные строки с
одним id как в рамках одной таблицы, так и в рамках этой группы таблиц. Hibernate будет следить за этим.

Можно написать простой HQL-запрос, чтобы получить всех пользователей: User, Employee, Client:

```
List<User> accounts = session.createQuery("from User").list(); 
```

А вот Hibernate, в свою очередь, сгенерирует очень интересный запрос. Он сделает выборку из всех таблиц, потом объединит
ее через UNION ALL в подобие виртуальной таблицы, и только потом будет выполнять по ней поиск и/или выборку. Но чтобы
объединить таблицы с разными колонками, сначала их нужно дополнить фейковыми колонками. Например, таблицу user нужно
дополнить колонками:

- occupation VARCHAR
- salary INT
- join DATE
- address VARCHAR

- Пример SQL-запроса к таблице user перед выполнением UNION ALL:

```
SELECT   id,
         name,
         birthday,
         CAST(NULL AS VARCHAR) AS occupation,
         CAST(NULL AS INT) AS salary,
         CAST(NULL AS DATE) AS join,
         CAST(NULL AS VARCHAR) AS address,
         0 AS clazz
FROM  user
```

Пример SQL-запроса к таблице employee перед выполнением UNION ALL:

```
SELECT   id,
         name,
         birthday,
         occupation,
         salary,
         join,
         CAST(NULL AS VARCHAR) AS address,
         1 AS clazz
FROM  employee
```

Пример SQL-запроса к таблице client перед выполнением UNION ALL:

```
SELECT  id,
        name,
        birthday,
        CAST(NULL AS VARCHAR) AS occupation,
        CAST(NULL AS INT) AS salary,
        CAST(NULL AS DATE) AS join,
        address,
        2 AS clazz
FROM client
```

Хорошая новость: HQL-запросы будут работать так, как надо. Плохая новость: они могут работать медленно, если данных в
таблицах очень много, потому что сначала данные нужно выбрать из всех таблиц, потом объединить их строки с помощью UNION
ALL, только потом фильтровать.

**Выбор стратегии сохранения иерархии**  
Стратегия TABLE_PER_CLASS на основе UNION Данную стратегию лучше выбирать, если полиморфные запросы и ассоциации не
требуются. Если ты редко выполняешь (или не выполняешь вообще) “select user from User user”. Если у тебя нет
Entity-классов, ссылающихся на User, этот вариант будет лучшим (поскольку возможность добавления оптимизированных
полиморфных запросов и ассоциаций сохранится).

Стратегия SINGLE_TABLE Данную стратегию стоит использовать:

а) Только для простых задач. В ситуациях, когда нормализация и ограничение NOT NULL являются критическими, следует
отдать предпочтение стратегии №3 (JOINED). Имеет смысл задуматься, не стоит ли в данном случае полностью отказаться от
наследования и заменить его делегированием.

б) Если требуются полиморфные запросы и ассоциации, а также динамическое определение конкретного класса во время
выполнения. При этом подклассы объявляют относительно мало новых полей, и основная разница с суперклассом заключается в
поведении.

Стратегия JOINED Данная стратегия самая эффективная по скорости и CONSTRAINTS. Она подойдет в случаях, когда требуются
полиморфные запросы и ассоциации, но подклассы объявляют относительно много новых полей.

Здесь стоит оговориться: решение между JOINED и TABLE_PER_CLASS требует оценки планов выполнения запросов на реальных
данных, поскольку ширина и глубина иерархии наследования могут сделать стоимость соединений (и, как следствие,
производительность) неприемлемыми.

Отдельно стоит принять во внимание, что аннотации наследования невозможно применить к интерфейсам.
[К оглавлению &#8593;](#Оглавление)

## 11 Можно ли создать собственный тип данных?

Да, можно. Для этого необходимо:

1. Создать класс, который будет описывать наш новый тип (например, LocalTimeStringType)
2. Класс нужно наследовать от AbstractSingleColumnStandardBasicType<<E> (возьмём LocalTime вместо E)
3. Создать класс – аналог конвертера, который будет содержать два метода – wrap() и unwrap() для преобразования значений
   типа LocalTime в String (просто для примера, типы могут быть любыми).
4. Наследовать этот класс от AbstractTypeDescriptor<LocalTime>
5. Реализовать методы wrap() и unwrap()
6. Готово. Можно использовать класс LocalTimeStringType для хранения времени в виде строки:

[К оглавлению &#8593;](#Оглавление)

## 12 Какие коллекции поддерживаются на уровне mapping?

Маппинг коллекций объектов:

- Array – массив объектов
- List – список объектов
- Set – множество объектов
- Map – словарь объектов
- Collection – коллекция объектов

Допустим, у нас есть класс с полем-коллекцией. ЧТобы хранить не одно поле, а много значений, необходимо над
полем-коллекцией поставить аннотацию @ElementCollection.

Все поля Entity-класса, которые содержат много элементов и помечаются с помощью аннотации @ElementCollection, содержатся
в базе данных в специальной вспомогательной таблице. Эта таблица может содержать данные в двух видах:

Упорядоченные (List, Map) содержат три колонки:

+ Key Column (Foreign Key) – ссылка на ID объекта-родителя.
+ Index Column – позиция/индекс в коллекции.
+ Element Column – значение.

Неупорядоченные (Set) содержат две колонки:

+ Key Column (Foreign Key) – ссылка на ID объекта-родителя.
+ Element Column – значение.

Также можно задать имя этой таблицы с помощью аннотации:

@CollectionTable(name="имя_таблицы")

Если аннотация @CollectionTable не указана, то Hibernate сам построит имя таблицы на основе имени класса и имени поля.

Создадим вспомогательную таблицу сами:

```sql
CREATE TABLE user_message
(
    user_id INT,
    message VARCHAR(255)
);
```

У этой таблицы нет своей id-колонки. Это и есть основной признак вспомогательных таблиц. Теперь нужно замапить эту
таблицу на поле messages в классе User:

```java

@Entity
@Table(name = "user")
class User {
    @Id
    @Column(name = "id")
    public Integer id;

    @ElementCollection
    @CollectionTable(name = "user_message", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "message")
    public Set<String> messages;
}
```

**Коллекция List**  
Если во вспомогательной таблице требуется хранить упорядоченные элементы списка или массива, то понадобится таблица с
тремя колонками:

```sql
CREATE TABLE user_message
(
    user_id INT,
    index   INT,
    message VARCHAR(255)
);
```

Если не нравится имя колонки "index", то можно указать другое имя во время маппинга. Для этого нужно использовать
аннотацию @Index:

```java

@Entity
@Table(name = "user")
class User {
    @Id
    @Column(name = "id")
    public Integer id;

    @ElementCollection
    @CollectionTable(name = "user_message",
            indexes = {@Index(columnList = "list_index")},
            joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "message")
    public List<String> messages;
}
```

**Коллекция Map**
Если требуется сохранять не просто коллекцию, а HashMap, то нужны две колонки во вспомогательной таблице:

```sql
CREATE TABLE user_message
(
    user_id INT,
    key     VARCHAR(255),
    message VARCHAR(255)
);
```

Для того чтобы указать ключ для Map, понадобится аннотация @MapKeyColumn:

```java

@Entity
@Table(name = "user")
class User {
    @Id
    @Column(name = "id")
    public Integer id;

    @ElementCollection
    @CollectionTable(name = "user_message", joinColumns = @JoinColumn(name = "user_id"))
    @MapKeyColumn(name = "key")
    @Column(name = "message")
    public Map<String, String> messages;
}
```

[К оглавлению &#8593;](#Оглавление)

## 13 Зачем нужен класс Transactional?

Для декларативного управления транзакциями можно использовать Spring Framework. Управление транзакциями осуществляется
через менеджер транзакций. Вместо вызовов session.openTransaction() и session.commit() используется аннотация
@Transactional.

Аннотация @Transactional указывает, что метод должен выполняться в транзакции. Менеджер транзакций открывает новую
транзакцию и создаёт для неё экземпляр Session, который доступен через sessionFactory.getCurrentSession(). Все методы,
которые вызываются в методе с данной аннотацией, также имеют доступ к этой транзакции, потому что экземпляр Session
является переменной потока (ThreadLocal). Вызов sessionFactory.openSession() откроет совсем другую сессию, которая не
связана с транзакцией.

[К оглавлению &#8593;](#Оглавление)

## 14 Расскажите про уровни изоляции? Какие уровни поддерживаются в hibernate? Как их устанавливать?

Уровень изолированности - это условный уровень консистентности данных, который может быть достигнут при выполнении
параллельных транзакций. Грубо говоря, это те ограничения, на которые мы готовы пойти, выполняя параллельные запросы в
базу, чтобы сохранить целостность данных.

Уровень изолированности - это часть требований ACID (atomicity - атомарность, consistency - согласованность, isolation -
изолированность и durability - надежность). Реляционные базы данных в большинстве своём должны удовлетворять этим
требованиям. Части этих требований удовлетворяют и некоторые нереляционные базы.

**Какие проблемы можно решить**  
Выбор подходящего уровня изолированности позволяет справиться с несколькими из проблем:

- dirty read - с чтением данных, которые могут пропасть после отката;
- non repeatable read - с повторным чтением, которое может вернуть изменившиеся данные;
- phantom read - с повторным чтением, которое может вернуть отличающееся количество строк;
- lost update - с потерянным изменением.

В стандарте SQL от ANSI/ISO, сформулированном еще в 1992 году, описаны четыре уровня:

+ Read uncommitted - чтение незафиксированных данных;
+ Read committed - чтение зафиксированных данных;
+ Repeatable read - повторяющееся чтение;
+ Serializable - упорядочиваемость.

Некоторые современные базы данных также реализуют еще один уровень:

+ Snapshot (опционально) - снимок состояния (четкого определения я в источниках не нашел, поэтому назвал это просто
  снимком состояния).

Эти уровни выстроены по степени от наименьшей консистентности к наибольшей. Т.е. чтение незафиксированных данных дает
нам наибольшую вероятность прочитать информацию, которая была изменена соседней транзакцией. А serializable фактически
выстраивает транзакции в очередь - они выполняются друг за другом.

[К оглавлению &#8593;](#Оглавление)

## 15 Что такое OptimisticLock? Расскажите стратегии создания через version, timestamp.

Блокировки – это меры по предотвращению модификации данных в реляционной базе данных между временем их чтения, и
временем их использования. Стратегия блокировок может быть либо оптимистичной, либо пессимистичной.

Стратегии блокировок

**_Оптимистичная_**  
Оптимистичные блокировки предполагают, что множество транзакций могут завершиться без влияния друг на друга, а значит,
могут выполняться без блокировок тех ресурсов, на которые они влияют. Перед коммитом, каждая транзакция проверяет, что
ни одна другая транзакция не модифицировала ее данные. Если проверка выявила конфликтующие модификации, транзакция,
находящаяся в состоянии коммита, откатывается.

_**Пессимистичная**_  
Пессимистичная стратегия подразумевает, что параллельные транзакции будут конфликтовать каждая друг с другом, и требует
блокировки ресурсов после их чтения, а также ее снятия только после того, как приложение завершило использование данных.

Оптимистическая блокировка основана на обнаружении изменений в сущностях путем проверки их атрибута версии. Если
происходит какое-либо параллельное обновление, возникает OptmisticLockException. После этого мы можем повторить попытку
обновления данных.

Такой механизм подходит для приложений, которые выполняют гораздо больше операций чтения, чем обновления или удаления.
Более того, это полезно в ситуациях, когда объекты должны быть отсоединены в течение некоторого времени, а блокировки не
могут быть удержаны.

Напротив, пессимистический механизм блокировки предполагает блокировку сущностей на уровне базы данных. Каждая
транзакция может получить блокировку данных. Пока он удерживает блокировку, ни одна транзакция не может читать, удалять
или обновлять заблокированные данные. Мы можем предположить, что использование пессимистической блокировки может
привести к взаимоблокировкам. Однако она обеспечивает большую целостность данных, чем оптимистическая блокировка.

**Оптимистичные блокировки**

Вы можете хранить версионированные данные, когда ваше приложение использует долгоживущие транзакции или диалоги,
покрывающие несколько БД-транзакций. Таким образом, если одна и та же сущность будет модифицироваться двумя диалогами,
последний диалог, коммитивший изменения, будет оповещен о конфликте, и не перезапишет результаты другого диалога. Этот
подход гарантирует некоторую степень изоляции, но при этом хорошо масштабируется, и довольно неплохо себя показывает в
ситуациях Read-Often Write-Sometimes. Hibernate предоставляет два различных механизма для хранения версионной информации
– выделенный номер версии, или временную метку (timestamp).

Свойство версии или временной метки не может быть null для отсоединенных (detached) объектов. Hibernate распознает любой
экземпляр с версией (или временной меткой), равной null, как transient, в независимости от других стратегий
unsaved-value, которые вы указываете. Объявление null-ового свойства версии или временной метки – легкий способ избежать
проблемы с транзитивным повторным соединением(transitive reattachment) в Hibernate, являющееся особенно полезным в
случаях, где вы используете присоединенные (assigned) идентификаторы или композитные ключи.

* unsaved-value – стратегия определения операции UPDATE или INSERT для синхронизации с БД, зависящая от значения
  свойства, проецирующегося с помощью id, version, или timestamp (прим. перев.)

Чтобы использовать оптимистическую блокировку, нужна сущность с аннотацией **_@Version_**. При его использовании каждая
транзакция, которая считывает данные, содержит значение свойства версии.

```java

@Entity
public class Flight implements Serializable {
    @Version
    @Column(name = "OPTLOCK")
    public Integer getVersion() {...}
}
```

Прежде чем транзакция захочет выполнить обновление, она снова проверяет свойство версии.

Если за это время значение изменилось, создается исключение OptimisticLockException. В противном случае транзакция
фиксирует обновление и увеличивает значение свойства версии.

**_Timestamp_**

Временные метки (timestamps) — менее надежный способ оптимистичных блокировок, чем номера версий, который также может
быть использован приложениями для других целей. Временные метки используются автоматически, если вы используете
аннотацию Version на свойстве типа Date или Calendar:

```java

@Entity
public class Flight implements Serializable {
    @Version
    public Date getLastUpdate() {...}
}
```

Hibernate может извлечь значение временной метки из базы данных или JVM, прочитав значение аннотации
org.hibernate.annotations.Source. Значение может быть либо org.hibernate.annotations.SourceType.DB, либо
org.hibernate.annotations.SourceType.VM. Поведение по-умолчанию – это использование БД, также используемое, если вы не
укажете аннотацию. Временная метка также может быть сгенерирована базой данных, вместо Hibernate, если вы используете
аннотацию org.hibernate.annotations.Generated(GenerationTime.ALWAYS).

[К оглавлению &#8593;](#Оглавление)

## 16 Расскажите про стратегии извлечения данных eager, lazy?

**FetchType.LAZY**
Когда используется LAZY, данные не извлекаются до тех пор, пока они действительно не понадобятся. Представьте себе
ситуацию, когда у вас есть приложение, которое работает с книгами и авторами. Каждый автор может написать несколько
книг. Но есть случаи, когда вам нужно получить информацию только об авторе, без деталей о его книгах. В этом случае LAZY
подходит идеально, поскольку он позволяет избежать ненужного извлечения данных о книгах.

**FetchType.EAGER**
С другой стороны, EAGER загружает все данные сразу. Вернемся к примеру с книгами и авторами. Если каждый раз при выборе
автора вам нужна информация о его книгах, использование EAGER будет более эффективным. Этот метод извлечения загружает
все связанные данные одновременно, что уменьшает количество запросов к базе данных.

Однако использование EAGER может привести к проблемам производительности, если размер данных большой. Извлечение больших
объемов данных может замедлить работу приложения.

В зависимости от ситуации и требуемой производительности, можно выбирать между LAZY и EAGER. Основная идея состоит в
том, чтобы получить данные, когда они действительно нужны, и избегать извлечения ненужных данных.

[К оглавлению &#8593;](#Оглавление)

## 17 Что такое объект Proxy? С чем связана ошибка LazyInitializationException? Как ее избежать?

Hibernate использует прокси-объекты для реализации ленивой загрузки (lazy load) связей "к-одному". Их также можно
использовать для улучшения производительности некоторых операций записи.

Часто LazyInitializationException дает вам понять, что вы работаете с прокси. Hibernate бросает это исключение, если вы
обращаетесь к геттеру или к любому полю, кроме первичного ключа, неинициализированного прокси-объекта.

[К оглавлению &#8593;](#Оглавление)

## 18 HQL. Расскажи основные элементы синтаксиса HQL? Простой запрос, запрос join? Создания объекта через конструктор.

Hibernate использует язык запросов (The Hibernate Query Language (HQL)), который похож по внешнему виду на SQL. Однако,
по сравнению с SQL, HQL полностью объектно-ориентирован и понимает такие понятия, как наследование, полиморфизм и
ассоциация.

За исключением имен классов и свойств Java, запросы не учитывают регистр. Таким образом, SeLeCT совпадает с SELEct таким
же, как SELECT, но org.hibernate.eg.FOO не является org.hibernate.eg.Foo, а foo.barSet не является foo.BARSET.

Самый простой возможный запрос Hibernate имеет вид:

from Cat

Чтобы обратиться к Cat в других частях запроса, вам нужно будет присвоить псевдоним (alias). Например:

from Cat as cat

Этот запрос присваивает псевдоним cat экземплярам Cat, поэтому вы можете использовать этот псевдоним позже в запросе.
Ключевое слово as необязательно. Вы также можете написать:

from Cat cat

Вы также можете назначать псевдонимы связанным сущностям или элементам коллекции значений с помощью join. Например:

from Cat as cat inner join cat.mate as mate left outer join cat.kittens as kitten

Поддерживаемые типы соединений заимствованы из ANSI SQL:

+ inner join
+ left outer join
+ right outer join
+ full join (редко полезен)

[К оглавлению &#8593;](#Оглавление)

## 19 Расскажите про уровни кешей в Hibernate?

Hibernate поддерживает три уровня кэширования:

- Кэширование на уровне сессии (Session) (First-level cache)
- Кэширование на уровне SessionFactory (Second-level cache)
- Кэширование запросов (и их результатов) (Query cache)

**Кэширование первого уровня**  
Hibernate по умолчанию всегда использует **кеширование на уровне сессии**, и его нельзя отключить. Данный вид
кеширования самый простой (его еще называют **кэшем первого уровня**) и реализован на уровне Hibernate-сессии. Например,
если сделать два одинаковых запроса в сессии:

```
Example example1 = session.get(Example.class,4);
Example example2 = session.get(Example.class,4);

assertTrue(example1 == example2);
```

После первого запроса в базу объект Example будет закэширован. И после повторного запрос объекта в той же сессии
Hibernate вернет тот же Java-объект, т.е. ссылки на объекты будут идентичными. При использовании методов save(),
update(), saveOrUpdate(), load(), get(), list(), iterate() и scroll() всегда будет задействован кэш первого уровня.

**Кэширование второго уровня**  
Кэш второго уровня привязан к объекту SessionFactory, а значит, видимость объектов в этом кэше гораздо шире, чем в кэше
первого уровня.

```
Session session = factory.openSession(); 
Example example1 = session.get(Example.class, 4); 
session.close();

session = factory.openSession(); 
Example example2 = session.get(Example.class, 4); 
session.close();

assertTrue(example1 != example2); 
assertTrue(example1.equals(example2));
```

В этом примере будет выполнено два запроса в базу. Hibernate вернет идентичные объекты, но это будет не тот же объект —
они будут иметь разные ссылки.

Кэширование второго уровня по умолчанию отключено. Поэтому мы имеем два запроса к базе вместо одного. Чтобы включить кэш
второго уровня, нужно в файле hibernate.cfg.xml прописать следующие свойства:

```
<property name="cache.use_second_level_cache">true</property>
<property name="cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
```

Над нужным классом указать аннотации:

```
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
```

После чего поведение Hibernate изменится:

```
Session session = factory.openSession();
Example example1 = session.get(Example.class, 4);
session.close();

session = factory.openSession();
Example example2 = session.get(Example.class, 4);
session.close();

assertTrue(example1 != example2);
assertTrue(example1.equals(example2);
```

В примере выше будет выполнен только один запрос в базу (первый). Во время второго запроса Hibernate возьмёт значения из
кэша, однако ссылки example1 и example2 будут разными, так как Hibernate сохраняет не сами объекты в кэш, а значения их
полей. Hibernate не хранит сами объекты классов. Он хранит информацию в виде массивов строк, чисел и т.д. И
идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта —
ключ, а массивы данных — значение. Можно представить себе это так:

```
1 -> { "Иванов", 1, null , {1,2,5} }
2 -> { "Петров", 2, null , {1,2,5} }
3 -> { "Сидоров", 3, null , {1,2,5} }
```

Помимо вышесказанного, следует помнить — зависимости Entity-класса по умолчанию также не кэшируются. Например, если
рассмотреть класс Employee, то при выборке коллекция tasks будет доставаться из БД, а не из кэша второго уровня.

Если требуется также кэшировать и зависимости, то класс должен выглядеть так:

```java

@Entity
@Table(name = "employee")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Employee {
    @Id
    private Integer id;

    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private Set<Task> tasks;
}
```

И последняя деталь — чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в
кэше первого уровня.

О кэшировании первого и второго уровней:
Когда сессии Hibernate нужно загрузить сущность, она всегда ищет кэшированную копию сущности в кэше первого уровня. Если
такая копия существует, то возвращается эта копия, если нет, то поиск продолжается в кэше второго уровня. Если копия
найдена в кэше второго уровня, то она возвращается, но перед этим копия сущности записывается в кэш первого уровня. Если
копии сущности нет ни в кэше первого уровня, ни второго уровня, выполняется sql запрос и возвращается сущность из
таблицы баз данных, но перед этим копия сущности сохраняется в кэше первого и второго уровня. В кэш второго уровня
заносятся все изменения, которые были сделаны в сессии. Кеш второго уровня может стать не актуальным, если таблицу базы
данных редактируют напрямую sql запросами, в обход hibernate сессии, в таком случаи нужно обнулять/затирать кэш. Стоит
отметить, что кэш первого уровня и второго уровня применим только **к одиночным сущностям**, т.е. когда запрашивается
один объект методами .get() или .load() сессии.

**Кэширование третьего уровня**

```
Example example1 = session.createQuery("from Example where id = 4").uniqueResult();
Example example2 = session.createQuery("from Example where id = 4").uniqueResult();

assertTrue(example1 != example2);
```

Результаты такого рода запросов не сохраняются кэшем ни первого, ни второго уровня. Это как раз то место, где можно
использовать кэш запросов. Он тоже по умолчанию отключен. Для включения нужно добавить следующую строку в
конфигурационный файл:

```
<property name="cache.use_query_cache">true</property>
```

Но это только половина решения. Еще требуется указать, результаты каких запросов необходимо кэшировать. Это нужно
прописать в запросе Query:

```
Query query = session.createQuery("from Example where id = 4"); 
query.setCacheable(true); 
Example example1 = query.uniqueResult(); 
```

[К оглавлению &#8593;](#Оглавление)

## 20 Что такое StatelessSessionFactory? Зачем он нужен, где он используется?

StatelessSession предоставляет командно-ориентированный API. Этот функционал доступен только в Hibernate и не включен в
JPA.

StatelessSession не предоставляет кэш первого уровня, сравнение состояния объектов (dirty checks) или write-behind. Он
также не обеспечивает ленивую загрузку связей и не использует кэши второго и третьего уровней. Любая операция также не
вызывает никаких событий жизненного цикла или перехватчиков. Вместо всех функций, которые предоставляет обычный Session
или EntityManager в JPA, мы получаем полный контроль над выполняемыми SQL-запросами.

Если требуется получить какие-то данные из базы данных или инициализировать связь между сущностями, нужно написать и
выполнить соответствующий запрос. А если требуется создать новый или изменить существующий объект сущности, нужно
вызвать метод insert(), update() или delete() интерфейса StatelessSession, чтобы сохранить изменения. Это требует
большего внимания к технической стороне слоя хранения данных (persistence layer). И если задачи не требуют сравнения
состояния объектов (dirty checks), ленивой загрузки или кэшей первого уровня, использование StatelessSession значительно
снижает накладные расходы на производительность, которые добавляют все эти функции.

StatelessSession отлично подходит для случаев, когда импортируется или обновляется огромный набор данных. Также можно
использовать StatelessSession, если нужно получить много объектов сущностей, которые не будут изменяться.

Типичными примерами использования StatelessSession являются пакетные задания или другие сценарии использования, которые
выполняют множество простых операций записи.

[К оглавлению &#8593;](#Оглавление)

## 21 Зачем нужен режим read-only?

Настройка кэша второго уровня. У Hibernate есть 4 возможных стратегии доступа для кэшируемой сущности, если к ней
обращаются из разных потоков:

+ read-only
+ read-write
+ nonstrict-read-write
+ transactional

**Только для чтения (read-only)**  
Стратегия параллелизма, подходящая для данных, которые никогда не изменяются. Hibernate будет просто хранить эти объекты
у себя в памяти. Данную стратегию уместно использовать для справочных данных.

В базах данных хранится очень много информации, которая никогда не меняется. Например, таблица хранит список событий,
которые только добавляются, но никогда не изменяются и не удаляются. Если тебе нужно работать с этой таблицей через
Hibernate, то тебе подойдет стратегия кэширования read-only.

**Чтение-запись (read-write)**  
Используй эту стратегию для данных, предназначенных главным образом для чтения. Однако Hibernate будет отслеживать
попытки изменения этих данных, хотя и рассчитывает, что они будут очень редкими.

Кэшировать нужно в основном те объекты, которые редко меняются и часто читаются/запрашиваются. Если есть такие объекты,
то для них нужно использовать стратегию read-write.

**Nonstrict-read-write**.  
Эта стратегия не гарантирует согласованности между кэшем и базой данных. Используй эту стратегию, если данные почти
никогда не изменяются и небольшая вероятность устаревших данных не является критической проблемой.

В отличие от стратегии read-write, эта стратегия подразумевает, что изменяемые данные не лочатся на чтение. Это может
привести к тому, что объект изменился в одном месте, а в другом кто-то читает его старую версию.

Например, пользователь изменил свой комментарий, но остальные пользователи еще какое-то время видят его старую версию.
Если это не является проблемой, тогда можно использовать стратегию nonstrict-read-write.

**Транзакционный**  
Используй эту стратегию для данных, предназначенных главным образом для чтения, где важно предотвратить устаревшие
данные в параллельных транзакциях в редких случаях обновления.

[К оглавлению &#8593;](#Оглавление)